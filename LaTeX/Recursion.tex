\documentclass{article}
\usepackage{forest}
\usepackage{listings}
\usepackage{multicol}

\title{Trees}
\setlength{\columnsep}{3cm}

\begin{document}
\maketitle

\begin{center}
  \rule{0.5\textwidth}{0.4pt}
\end{center}

\section{Binary Trees}
\begin{itemize}
  \item{A Binary Tree is a collection of nodes}
  \begin{itemize}
    \item{Each node has a left and a right pointer}
    \item{A root node indicates the start of the tree}
    \item{If the root is \textit{None}, the tree is empty}
  \end{itemize}
  \item{A Binary Search Tree is a binary tree where the value of any node is:}
  \begin{itemize}
    \item{Greater than all the values in it's left subtree}
    \item{Less than all the values in it's right subtree}
  \end{itemize}
\end{itemize}

\begin{center}
  \begin{forest}
  [52 [8 [3] [15 [,phantom] [39]]] [66 [,phantom] [79]]]
  \end{forest}
\end{center}

\begin{center}
  \rule{0.5\textwidth}{0.4pt}
\end{center}

\pagebreak

\section{Defining a Binary Search Tree}
\begin{lstlisting}[language=Python, frame=single]
class Node:
    def __init__(self, item, left=None, right=None):
        self.item = item
        self.left = left
        self.right = right

class BST:
    def __init__(self):
        self.root = None

    def rec_add(self, node, item):
        if node == None:
            return Node(item)
        elif item < node.item:
            node.left = self.rec_add(node.left, item)
        else:
            node.rigth = self.rec_add(node.right, item)
        return node

    def add(self, item):
        self.root = self.rec_add(self.root, item)
\end{lstlisting}

\begin{center}
  \rule{0.5\textwidth}{0.4pt}
\end{center}

\section{Tree Traversals}
\begin{itemize}
  \item{Tree Traversal is just a way to access every element in the tree}
  \item{This can be done in 3 orders;}
  \begin{itemize}
    \item{InOrder}
    \item{PreOrder}
    \item{PostOrder}
  \end{itemize}
\end{itemize}

\begin{center}
  \rule{0.5\textwidth}{0.4pt}
\end{center}

\pagebreak

\section{AVL trees}
\begin{itemize}
  \item{An \textit{AVL} tree is a Binary Search Tree where the height is maintained to $O(logN)$}
  \begin{itemize}
    \item{This is done by adjusting the tree when it becomes unbalanced}
    \item{A tree is considered unbalanced when the difference between the 2 child nodes is greater than 1}
    \item{The \textit{add} and \textit{delete} operations need to be restructured to maintain balance}
  \end{itemize}
\end{itemize}

\begin{multicols}{4}
  [There are 4 ways that a tree can become unbalanced]
    \begin{forest}
      [8 [,phantom] [20 [,phantom] [24]]]
    \end{forest}\\
    Right-Right

    \begin{forest}
      [8 [6 [2] [,phantom]] [,phantom]]
    \end{forest}\\
    Left-Left

    \begin{forest}
      [8 [,phantom] [20 [15] [,phantom]]]
    \end{forest}\\
    Right-Left

    \begin{forest}
      [18 [9 [,phantom] [15]] [,phantom]]
    \end{forest}\\
    Left-Right

\end{multicols}

\begin{multicols}{4}
  [In each case, the tree can be balanced by replacing the root with the middle element]
  \begin{forest}
    [20 [8] [24]]
  \end{forest}
  \\
  \begin{forest}
    [6 [2] [8]]
  \end{forest}
  \\
  \begin{forest}
    [15 [8] [20]]
  \end{forest}
  \\
  \begin{forest}
    [15 [9] [18]]
  \end{forest}
\end{multicols}

\begin{center}
  \rule{0.5\textwidth}{0.4pt}
\end{center}

\section{AVL adding an element}
\begin{itemize}
  \item{Add the node to the tree}
  \item{Starting at this node, move up the tree towards the root, checking to see if any node is unbalanced}
  \begin{itemize}
    \item{If it is, find out which case it is and perform the corresponding restructuring}
    \item{Do this every time an element is added}
    \item{It seems like a lot of work, but it's only $O(logN)$}
    \item{No more than one restructuring is required per insert}
  \end{itemize}
\end{itemize}

\begin{lstlisting}[language=Python, frame=single]
\end{lstlisting}
\end{document}
